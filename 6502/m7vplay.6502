\ ******************************************************************
\ * Bad Apple
\ * Video player in MODE 7
\ * Kieran Connell & Simon Morris
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

osfile = &FFDD
oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
osfind = &FFCE
osgbpb = &FFD1

argv = &F2

IRQ1V = &204
IRQ2V = &206
EVENTV = &0220

INKEY_esc = 112
INKEY_q = 16

SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea
JMP_OP = &4C


\ ******************************************************************
\ *	Define debug flags
\ ******************************************************************

_DEBUG = TRUE
_WAIT_KEYPRESS = FALSE				; could implement play/pause/step
_ENABLE_WALLCLOCK = TRUE
_COUNT_DECRUNCHES = FALSE
_TRY_TO_MATCH_FRAMERATE = FALSE
_CHECK_LOAD_BUFFER = FALSE

_ENABLE_CMD_LINE_PARAMS = FALSE

_MUSIC_START_DELAY = 30

_MUS_BUFFER_2K = TRUE		; enable this to use the 'final' version of the music

_SHOW_INTRO = TRUE	; probably not needed as a define anymore. 

_SHOW_VIDEO_DEBUG = FALSE	; show the debug video data stuff, turn this OFF for final release

_HACK_CREDITS = FALSE ; force credits to show in intro (for testing)


\ ******************************************************************
\ *	Define macros
\ ******************************************************************

MACRO WAIT_FOR_KEYPRESS key
{
	.wait_for_keypress
	LDA #key:STA &FE4F:LDA &FE4F:BPL wait_for_keypress
}
ENDMACRO

\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_buffer_len = 3072			; was 4096

\\ MODE 7
MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25
MODE7_screen_size = (MODE7_char_width * MODE7_char_height)

MODE7_texel_width = (MODE7_char_width - 2) * 2
MODE7_texel_height = MODE7_char_height * 3

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154


\ ******************************************************************
\ *	Define app constants
\ ******************************************************************

VID_default_mode7_ypos = 2
VID_default_frame_height = 22		; 19
VID_default_frame_size = (MODE7_char_width * VID_default_frame_height)
VID_default_frame_addr = MODE7_base_addr + (VID_default_mode7_ypos * MODE7_char_width)

DFS_sector_size = 256
DFS_sectors_per_track = 10
DFS_sectors_to_load = 10
DFS_track_size = (DFS_sectors_per_track * DFS_sector_size)

DISK1_drive_no = 0			; for loop!
DISK1_first_track = 8		; the track at which the video file is located on side 0; all tracks prior to this are reserved for code
DISK1_last_track = 80		; could potentially deduce these from DFS catalog

DISK2_drive_no = 2			; should be 2
DISK2_first_track = 1
DISK2_last_track = 80		; doesn't actually matter as data stream should indicate end of buffer

STREAM_buffer_size = (3 * DFS_track_size)

TIMER_latch = 20000-2		; 20ms = 1x vsync :)

FX_frame = 343				; frame to turn on separated gfx - at apple cut / invert

\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_zp_src_hi = $70
EXO_zp_src_lo = EXO_zp_src_hi + 1
EXO_zp_src_bi = EXO_zp_src_hi + 2
EXO_zp_bitbuf = EXO_zp_src_hi + 3

EXO_zp_len_lo  = $74
EXO_zp_len_hi  = EXO_zp_len_lo + 1

EXO_zp_bits_lo = $76
EXO_zp_bits_hi = EXO_zp_bits_lo + 1

EXO_zp_dest_hi = $78
EXO_zp_dest_lo = EXO_zp_dest_hi + 1	; dest addr lo
EXO_zp_dest_bi = EXO_zp_dest_hi + 2	; dest addr hi

\\ Our own app variables
ORG &7B
GUARD &9F

\\ System vars
.writeptr				SKIP 2
.readptr				SKIP 2

.num_deltas				SKIP 2
.packed_delta			SKIP 2
.shifted_bit			SKIP 1
.frame_no				SKIP 2
.error_flag				SKIP 1
.vsync_count			SKIP 1
.decode_lock			SKIP 1
.sector_no				SKIP 1
.track_no				SKIP 1
.load_to_HI				SKIP 1
.xpos					SKIP 1


IF _ENABLE_WALLCLOCK
.clock_vsync			SKIP 1
.clock_secs				SKIP 1
ENDIF

IF _WAIT_KEYPRESS
.key_held				SKIP 1
ENDIF

IF _DEBUG
.debugptr				SKIP 2
ENDIF

IF _COUNT_DECRUNCHES
.decrunch_count			SKIP 2
ENDIF


\ ******************************************************************
\ *	MUSIC PLAYER
\ ******************************************************************

INCLUDE "6502\exomiser.h.asm"
INCLUDE "6502\vgmplayer.h.asm"


\ ******************************************************************
\ *	STEAL OS MEMORY
\ ******************************************************************

; -------------------------------------------------------------------
; this 156 byte table area may be relocated. It may also be clobbered
; by other data between decrunches.
; -------------------------------------------------------------------
decrunch_table = &A00
;.decrunch_table SKIP 156
tabl_bi = decrunch_table
tabl_lo = decrunch_table + 52
tabl_hi = decrunch_table + 104

clock_param = &0000

mus_decrunch_table = &B00
;.mus_decrunch_table  SKIP MUS_TABL_SIZE
MUS_tabl_bi = mus_decrunch_table
MUS_tabl_lo = MUS_tabl_bi + 52
MUS_tabl_hi = MUS_tabl_bi + 104




\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1100	      					; code origin - assume standard BBC Micro
GUARD &7C00							; ensure code size doesn't hit start of screen memory

.start


\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop including high-level state machine
\ ******************************************************************

.main
{
\\ Determine command line params

IF _ENABLE_CMD_LINE_PARAMS
	JSR cmd_line_params
ENDIF

\\ ***** System initialise ***** \\

	\\ *FX 200,3 - clear memory on break as we use OS memory areas and can cause nasty effects
	LDA #200
	LDX #3
	JSR osbyte	

	\\ Set MODE 7
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch

	\\ Turn off cursor by directly poking crtc
	\\ saves a few bytes this way. might not even need SEI/CLI
	SEI
	LDA #10: STA &FE00
	LDA #32: STA &FE01
	CLI	

	; copy credits data to CREDITS_DATA_ADDR for later use
	jsr relocate_credits

IF _SHOW_INTRO
	; show the intro sequence
	jsr introz
ENDIF

.start_demo

	\\ Set gfx mode
	LDX #0
	LDA #MODE7_graphic_black+7
	JSR teletexel_init

	\\ Zero our variables
	LDA #0
	STA frame_no
	STA frame_no+1
	STA error_flag
	STA decode_lock
	STA sector_no

	IF _ENABLE_WALLCLOCK
	STA clock_secs
	ENDIF
	IF _COUNT_DECRUNCHES
	STA decrunch_count
	STA decrunch_count+1
	ENDIF

	LDA #&FF
	STA vsync_count
	IF _ENABLE_WALLCLOCK
	STA clock_vsync
	ENDIF

	\\ Initialise music

	LDX #LO(music_data)
	LDY #HI(music_data)
	JSR vgm_init_stream
	BMI read_error

	\\ Zero system clock
	.^main_start_clock
	JSR device_test_start_clock

	\\ Load our entire stream buffer from first track

	LDA #DISK1_drive_no
	STA osword_params_drive				; this gets blatted at side change - need to reset for loop!

	LDA #DISK1_first_track
	STA track_no

	LDA #HI(STREAM_buffer_start)
	STA load_to_HI

	\\ Fill entire buffer
	{
		.loop
		JSR load_next_track
		
		LDA error_flag
		BNE read_error
	
		LDA load_to_HI
		CMP #HI(STREAM_buffer_start)			; wrapped means buffer filled
		BNE loop
	}

	JMP read_success

	.read_error
	JMP return

	.read_success

	\\ Read system clock
	.^main_stop_clock
	JSR device_test_stop_clock

	\\ Start decompressor
	LDX #LO(STREAM_buffer_start - 1)
	LDY #HI(STREAM_buffer_start - 1)
	JSR init_decruncher

	\\ Decode stream header
	JSR get_decrunched_byte		; frame_size_LO
	BCS read_error

	\\ Calculate frame_end address
	ADC VID_frame_start
	STA VID_frame_end
	PHP

	JSR get_decrunched_byte		; frame_size_HI
	BCS read_error
	PLP

	ADC VID_frame_start+1
	STA VID_frame_end+1

	LDA #19
	JSR osbyte

	\\ Enable irq
	{
		SEI
		LDA IRQ1V:STA old_irqv
		LDA IRQ1V+1:STA old_irqv+1
	
		LDA #LO(irq_handler):STA IRQ1V
		LDA #HI(irq_handler):STA IRQ1V+1		; set interrupt handler

		LDA #64						; A=00000000
		STA &FE4B					; R11=Auxillary Control Register (timer 1 latched mode)

		LDA #&C0					; A=11000000
		STA &FE4E					; R14=Interrupt Enable (enable timer 1 interrupt)

		LDA #LO(TIMER_latch/2)
		STA &FE44					; R4=T1 Low-Order Latches (write)
		LDA #HI(TIMER_latch/2)
		STA &FE45					; R5=T1 High-Order Counter
		
		LDA #LO(TIMER_latch)
		STA &FE46
		LDA #HI(TIMER_latch)
		STA &FE47
		CLI
	}

	\\ Start the music!

	IF _MUSIC_START_DELAY = 0
	LDX #LO(poll_player)
	LDY #HI(poll_player)
	JSR start_eventv
	ENDIF

	\\ Top of our loop
	.next_frame

	\\ Wait vsync
	LDA #19
	JSR osbyte

	IF _MUSIC_START_DELAY <> 0
	{
		.music_start_code
		LDA frame_no+1
		BNE not_ready
		LDA frame_no
		CMP #_MUSIC_START_DELAY
		BNE not_ready

		LDX #LO(poll_player)
		LDY #HI(poll_player)
		JSR start_eventv
		.not_ready
	}
	ENDIF

;	LDA vsync_count
;	.wait_for_vsync
;	CMP vsync_count
;	BEQ wait_for_vsync

	IF _DEBUG
	JSR write_debug_info
	ENDIF

	\\ Load more data if needed

	\\ Which page are we reading crunched data from?
	SEC
	LDA EXO_crunch_byte_hi

	\\ Is it more than a "track" away?
	SBC load_to_HI
	.^sectors_to_load_1
	CMP #DFS_sectors_to_load
	BCC not_ready_to_load

	\\ If so, load a track's worth of data into our buffer
	JSR load_next_track

	.not_ready_to_load
	\\ Check for errors
	LDA error_flag
	BNE track_load_error

	; check for keypress W
;    LDA#&81:LDX#LO(-34):LDY#&FF:JSR &FFF4:TYA:BNE quit

	JMP next_frame

	.track_load_error
	SEI
	LDA old_irqv:STA IRQ1V
	LDA old_irqv+1:STA IRQ1V+1		; set interrupt handler
	CLI

	\\ Stop the music!
	.wait_for_music
	LDA vgm_player_ended
	BEQ wait_for_music	

.quit
	JSR stop_eventv

	\\ Exit cleanly (we hope)
	.return


IF _SHOW_INTRO
.show_creditz
	jsr creditz

	{
		\\ Clear screen without mode change or damaging header
		LDA #HI(MODE7_base_addr + MODE7_char_width)
		STA clear_loop+2
		LDX #0
		LDA #32
		.clear_loop
		STA MODE7_base_addr + MODE7_char_width, X
		INX
		BNE clear_loop
		INC clear_loop + 2
		BPL clear_loop
	}

	jmp start_demo
ENDIF	
	RTS
}

\\ <drive no disk 1> <drive no disk 2> <screen y pos> <frame height>
\\ Returns number in A but only valid if carry clear

IF _ENABLE_CMD_LINE_PARAMS
.cmd_line_get_number
{
	\\ Skip whitespace

	.skip_whitespace
	LDA (argv),Y
	INY
	CMP #' '
	BEQ skip_whitespace

	\\ Check end of string
	CMP #13
	BEQ return

	\\ Check less than '0'
	CMP #'0'
	BCC return

	\\ Check greater than '9'
	CMP #'9'+1
	BCS return

	\\ Is a number, subtract ASCII '0'
	SEC
	SBC #'0'
	TAX

	\\ Next digit
	LDA (argv),Y

	\\ Check less than '0'
	CMP #'0'
	BCC no_digit

	\\ Check greater than '9'
	CMP #'9'+1
	BCS no_digit
	
	INY

	\\ Second digit
	SEC
	SBC #'0'
	STA add_digit+1

	\\ Add 10's
	LDA #0
	CPX #0
	BEQ add_digit
	CLC
	.loop10
	ADC #10
	DEX
	BNE loop10

	\\ A now contains first digit*10
	.add_digit
	ADC #0				; ** SELF-MODIFIED **
	EQUB &2C			; BIT immediate - skips next two instructions

	.no_digit
	TXA
	CLC
	RTS	

	.return
	SEC
	RTS
}

.cmd_line_params
{
	\\ Y pre-initialised

	.get_disk1
	JSR cmd_line_get_number
	BCS get_disk2
	CMP #4
	BCS get_disk2
	STA osword_params_drive

	.get_disk2
	JSR cmd_line_get_number
	BCS get_ypos
	CMP #4
	BCS get_ypos
	STA TRACK_LOAD_disk_2+1

	.get_ypos
	JSR cmd_line_get_number
	BCS return
	CMP #25
	BCS return
	TAX

	\\ Calculate frame start
	CLC
	LDA #LO(MODE7_base_addr)
	ADC mode7_char_width_LO,X
	STA VID_frame_start
	LDA #HI(MODE7_base_addr)
	ADC mode7_char_width_HI,X
	STA VID_frame_start+1

	.return
	RTS
}
ENDIF



\ ******************************************************************
\ *	Debug on screen
\ ******************************************************************

IF _DEBUG
.write_debug_info
{
IF _SHOW_VIDEO_DEBUG
	\\ Reset our write ptr
	LDA #LO(MODE7_base_addr+40)
	STA debugptr
	LDA #HI(MODE7_base_addr+40)
	STA debugptr+1

	\\ Write debug info to screen


	LDY #0
	LDA EXO_crunch_byte_hi
	JSR debug_write_hex
	LDA EXO_crunch_byte_lo
	JSR debug_write_hex

	IF _COUNT_DECRUNCHES
	INY
	LDA decrunch_count+1
	JSR debug_write_hex
	LDA decrunch_count
	JSR debug_write_hex
	ENDIF

	INY
	CLC
	LDA osword_params_drive
	ADC #'0'
	STA (debugptr),Y
	INY
	LDA #'/'
	STA (debugptr),Y
	INY
	LDA track_no
	JSR debug_write_hex
	LDA #'/'
	STA (debugptr),Y
	INY
	CLC
	LDA sector_no
	ADC #'0'
	STA (debugptr),Y
	INY

	INY
	LDA load_to_HI
	JSR debug_write_hex
	LDA #0
	JSR debug_write_hex

	INY
	LDA vsync_count
	JSR debug_write_hex
ENDIF

	\\ write some debug info to the teletext header
	\\ Reset our write ptr
	LDA #LO(MODE7_base_addr)
	STA debugptr
	LDA #HI(MODE7_base_addr)
	STA debugptr+1


	LDY #20
	LDA frame_no+1
	JSR debug_write_hex
	LDA frame_no
	JSR debug_write_hex

	IF _ENABLE_WALLCLOCK
	LDY #36
	LDA clock_secs
	JSR debug_write_time
	ENDIF

	.return
	RTS
}
ENDIF

\ ******************************************************************
\ *	Video stream decode routines
\ ******************************************************************

.decode_frame_header
{
	\\ Get number of deltas in frame (16-bits)
	JSR get_decrunched_byte
	BCS return

	STA num_deltas				; NOT ACTUALLY NUM DELTAS + FRAME TYPE

	\\ Reset our write ptr
	LDA VID_frame_start			; #LO(VID_frame_addr)
	STA writeptr
	LDA VID_frame_start+1		; #HI(VID_frame_addr)
	STA writeptr+1

	.return
	RTS
}

.decode_entire_frame
{
	LDA #VID_default_frame_height			; num rows
	STA num_deltas

	.rows
	LDY #2

	.loop
	STY xpos

	JSR get_decrunched_byte
	BCS return				; read error

	TAX
	BEQ skip_line

	CMP #128
	BCS write_one_char

	CMP #64
	BCS write_many_blocks

	\\ write many spaces
	LDA #32
	LDY xpos
	.space_loop
	STA (writeptr), Y
	INY
	DEX
	BNE space_loop
	JMP check_end_of_row

	.write_many_blocks
	AND #&BF			; remove 64
	TAX
	LDA #127
	LDY xpos
	.block_loop
	STA (writeptr), Y
	INY
	DEX
	BNE block_loop
	JMP check_end_of_row

	.write_one_char
	LDY xpos
	STA (writeptr),Y
	INY

	.check_end_of_row
	CPY #MODE7_char_width
	BCC loop

	.skip_line
	DEC num_deltas
	BEQ return

	\\ Next row
	CLC
	LDA writeptr
	ADC #MODE7_char_width
	STA writeptr
	BCC no_carry
	INC writeptr+1
	.no_carry

	JMP rows

	.return
	CLC						; no read error
	RTS
}

.decode_frame_data
{
	\\ Check if this is a special frame before we start
	LDA num_deltas
	BEQ completed			; empty frame

	CMP #&FE
	BCS special_frame

	\\ Regular frame (deltas)

	.loop

	\\ Get low byte of offset
	JSR get_decrunched_byte
	BCS return
	STA packed_delta

	JSR get_decrunched_byte
	BCS return
	STA packed_delta+1
	
	\\ Decode offset (10 bits)
	CLC
	LDA packed_delta
	ADC writeptr
	STA writeptr

	LDA packed_delta+1
	AND #&3						; only need bottom 2 bits
	ADC writeptr+1
	STA writeptr+1

	\\ Decode pixels into MODE 7 byte (6 bits)
	\\ 00X1 1111
	\\ 0X01 1111
	\\ 0X11 1111

	LDA packed_delta+1
	AND #128					; top bit 7
	LSR A						; shift down to bit 6
	STA shifted_bit

	LDA packed_delta+1	
	LSR A
	LSR A						; shift down twice
	ORA #32						; always need 32 for MODE 7
	ORA shifted_bit				; mask in bit 6

	\\ Write to screen! (do this without indirect write?)
	LDY #0
	STA (writeptr),Y

	\\ Next delta
	DEC num_deltas
	BNE loop

	.completed
	CLC
	RTS

	.special_frame
	CMP #&FE
	BNE end_of_stream
	
	\\ Decode entire frame using Steve's codec
	JMP decode_entire_frame

	\\ End of stream
	.end_of_stream
	INC error_flag

	.return
	RTS
}

\ ******************************************************************
\ *	File loading routines
\ ******************************************************************

.load_next_track
\\{
	\\ Track &FF indicates no more reading
	LDA track_no
	BMI TRACK_LOAD_return

	\\ Store track no in params block
	STA osword_params_track

	LDA sector_no
	STA osword_params_sector

	\\ Update load address in params block
	LDA load_to_HI
	STA osword_params_address+1
	
	\\ Make DFS read multi-sector call
	LDX #LO(osword_params)
	LDY #HI(osword_params)
	LDA #&7F
	JSR osword

	\\ Error value returned at end of params block
	LDA osword_params_return
	STA error_flag

	\\ Next track
	CLC
	LDA sector_no
	.sectors_to_load_2
	ADC #DFS_sectors_to_load
	CMP #DFS_sectors_per_track
	BCC same_track
	SBC #DFS_sectors_per_track
	INC track_no
	.same_track
	STA sector_no

	\\ Which disk?
	LDA osword_params_drive
	BEQ TRACK_LOAD_disk_1							; assumes we start on drive 0

	\\ Disk 2
	LDA track_no
	CMP #DISK2_last_track
	BNE TRACK_LOAD_no_swap_disk

	\\ Reached end of disk 2
	LDA #&FF
	STA track_no
	BNE TRACK_LOAD_no_wrap				; and store &FF in load_to_HI

	\\ Disk 1
	.TRACK_LOAD_disk_1
	LDA track_no
	CMP #DISK1_last_track
	BNE TRACK_LOAD_no_swap_disk

	\\ Reached end of disk 1 so swap drives
	.TRACK_LOAD_disk_2
	LDA #DISK2_drive_no
	STA osword_params_drive

	\\ Reset track to start of disk 2
	LDA #DISK2_first_track
	STA track_no

	.TRACK_LOAD_no_swap_disk

	\\ Increment our load ptr
	CLC
	LDA load_to_HI
	.sectors_to_load_3
	ADC #DFS_sectors_to_load

	\\ Have we fallen off the end of the buffer?
	CMP #HI(STREAM_buffer_end)
	BNE TRACK_LOAD_no_wrap

	\\ If so then reset to start
	LDA #HI(STREAM_buffer_start)

	.TRACK_LOAD_no_wrap
	STA load_to_HI

	.TRACK_LOAD_return
	RTS
\\}


\ ******************************************************************
\ * IRQ
\ ******************************************************************

.old_irqv
EQUW &FFFF

.irq_handler
{
	LDA &FC
	PHA

	\\ Which interrupt?

	LDA &FE4D
	AND #&40			; timer 1
	BNE is_timer1

;	LDA &FE4D
;	AND #2
;	BNE is_vsync

	\\ Pass on to OS IRQ handler
	.return_to_os
	PLA
	STA &FC
	JMP (old_irqv)		; RTI

	.is_timer1
	\\ Acknowledge timer1 interrupt
	STA &FE4D

	\\ Increment vsync counter
	INC vsync_count

	IF _ENABLE_WALLCLOCK
	\\ Increment wall clock
	CLC
	LDA clock_vsync
	ADC #1
	CMP #50
	BCC no_secs
	INC clock_secs
	SBC #50
	.no_secs
	STA clock_vsync
	ENDIF

	\\ If we're already busy just exit function
	LDA decode_lock
	BNE return_timer1

	\\ If we're ahead of video frame rate early out
	LDA vsync_count
	BMI return_timer1

	\\ Set a lock on our decode function
	INC decode_lock
	
	\\ Increment frame counter
	{
		INC frame_no
		BNE no_carry
		INC frame_no+1
		.no_carry
	}

	\\ Frame FX
	{
		.test_fx_frame
		LDA frame_no+1
		CMP #HI(FX_frame)
		BNE no_fx
		LDA frame_no
		CMP #LO(FX_frame)
		BNE no_fx
		
		LDX #1
		LDA #MODE7_separated
		JSR teletexel_init
		.no_fx
	}

	\\ Store registers in case of interupts
	TXA:PHA:TYA:PHA

	\\ Decode frame header
	JSR decode_frame_header

	\\ Check for error
	BCS read_error

	\\ Decode the video frame
	CLI
	JSR decode_frame_data						; <-- this is the slowest bit!
	SEI

	.read_error
	BCC no_read_error

	\\ Indicate error
	INC error_flag

	.no_read_error
	\\ Restore registers
	PLA:TAY:PLA:TAX

	\\ Video data runs at 25Hz so take two frames off our sync counter

	DEC vsync_count
	DEC vsync_count

	\\ Remove our work lock
	DEC decode_lock

	.return_timer1

	\\ Exit
	PLA
	STA &FC
	JMP (old_irqv)		; RTI
}

\ ******************************************************************
\ *	Set up MODE 7 screen
\ ******************************************************************

; X=column, A=character code
.teletexel_init						; set blank screen
{
	FOR n,0,VID_default_frame_height-1
	addr=VID_default_frame_addr + n*MODE7_char_width
	STA addr, X
	NEXT

	.return
	RTS
}


\ ******************************************************************
\ *	Event Vector Routines
\ ******************************************************************

.old_eventv
EQUW 0

.start_eventv				; new event handler in X,Y
{
	\\ Set new Event handler
	sei
	LDA EVENTV
	STA old_eventv
	LDA EVENTV+1
	STA old_eventv+1

	stx EVENTV
	sty EVENTV+1
	cli
	
	\\ Enable VSYNC event.
	lda #14
	ldx #4
	jsr osbyte
	rts
}
	
.stop_eventv
{
	\\ Disable VSYNC event.
	lda #13
	ldx #4
	jsr osbyte

	\\ Reset old Event handler
	SEI
	LDA old_eventv
	STA EVENTV
	LDA old_eventv+1
	STA EVENTV+1
	CLI 

	rts
}

\ ******************************************************************
\ *	Debug helpers
\ ******************************************************************

IF _DEBUG
.debug_hexchars
EQUS "0123456789abcdef"

.debug_write_hex					; write A at (writeptr),Y
{
	PHA
	LSR A:LSR A:LSR A:LSR A
	TAX
	LDA debug_hexchars,X
	STA (debugptr),Y
	INY
	PLA
	AND #&0F
	TAX
	LDA debug_hexchars,X
	STA (debugptr),Y
	INY
	RTS
}

IF _ENABLE_WALLCLOCK
.debug_write_time					; write A at (writeptr),Y
{
	\\ Count sixties
	LDX #0
	.loop_60
	CMP #60
	BCC done_60
	SEC
	SBC #60
	INX
	JMP loop_60
	.done_60
	PHA
	TXA
	\\ Write  sixties
	TXA
	ADC #'0'
	STA (debugptr),Y
	INY

	LDA #':'
	STA (debugptr),Y
	INY
	PLA

	\\ Count tens
	LDX #0
	.loop_10
	CMP #10
	BCC done_10
	SEC
	SBC #10
	INX
	JMP loop_10
	.done_10
	PHA

	\\ Write  tens
	TXA
	ADC #'0'
	STA (debugptr),Y
	INY

	\\ Write units
	PLA	
	ADC #'0'
	STA (debugptr),Y
	INY

	RTS
}
ENDIF

ENDIF


\ ******************************************************************
\ *	Exomiser (decompression library)
\ ******************************************************************

; -------------------------------------------------------------------
; for this get_crunched_byte routine to work the crunched data has to be
; crunced using the -m <buffersize> and possibly the -l flags. Any other
; flag will just mess things up.

\\ ****
\\ THIS FUNCTION MUST PRESERVE STATUS FLAGS AND X & Y REGISTERS!
\\ ****
.get_crunched_byte
\\{
	PHP

	INC EXO_crunch_byte_lo
	bne EXO_byte_skip_hi
	INC EXO_crunch_byte_hi			; forward decrunch
.EXO_byte_skip_hi

	IF _CHECK_LOAD_BUFFER
	\\ Are we reading from the same page we intend to load at next?
	LDA EXO_crunch_byte_hi
	CMP load_to_HI
	BNE not_caught_up

	\\ If so then we have caught up with the disk load and run out of data
	\\ So bomb out with an error:
	INC error_flag
	LDA #0
	PLP
	RTS

	.not_caught_up
	ENDIF

	\\ Have we gone over the end of our stream buffer?
	LDA EXO_crunch_byte_hi
	CMP #HI(STREAM_buffer_end)
	BNE EXO_load_crunch_byte

	\\ If so then wrap around to the beginning
	LDA #LO(STREAM_buffer_start)
	STA EXO_crunch_byte_lo
	LDA #HI(STREAM_buffer_start)
	STA EXO_crunch_byte_hi

.EXO_load_crunch_byte
	lda STREAM_buffer_start-1	; **SELF-MODIFIED CODE**
EXO_crunch_byte_lo = EXO_load_crunch_byte + 1
EXO_crunch_byte_hi = EXO_load_crunch_byte + 2

	PLP
	rts						; decrunch_file is called.
\\}
; -------------------------------------------------------------------

; -------------------------------------------------------------------
; jsr this label to init the decruncher, it will init used zeropage
; zero page locations and the decrunch tables
; no constraints on register content, however the
; decimal flag has to be #0 (it almost always is, otherwise do a cld)
; -------------------------------------------------------------------
.init_decruncher				; pass in address of (crunched data-1) in X,Y
{
	STX EXO_crunch_byte_lo
	STY EXO_crunch_byte_hi

	jsr get_crunched_byte
	sta EXO_zp_bitbuf

	ldx #0
	stx EXO_zp_dest_lo
	stx EXO_zp_dest_hi
	stx EXO_zp_len_lo
	stx EXO_zp_len_hi
	ldy #0
; -------------------------------------------------------------------
; calculate tables (49 bytes)
; x and y must be #0 when entering
;
._init_nextone
	inx
	tya
	and #$0f
	beq _init_shortcut		; starta p√• ny sekvens

	txa			; this clears reg a
	lsr a			; and sets the carry flag
	ldx EXO_zp_bits_lo
._init_rolle
	rol a
	rol EXO_zp_bits_hi
	dex
	bpl _init_rolle		; c = 0 after this (rol EXO_zp_bits_hi)

	adc tabl_lo-1,y
	tax

	lda EXO_zp_bits_hi
	adc tabl_hi-1,y
._init_shortcut
	sta tabl_hi,y
	txa
	sta tabl_lo,y

	ldx #4
	jsr _bit_get_bits		; clears x-reg.
	sta tabl_bi,y
	iny
	cpy #52
	bne _init_nextone
}
\\ Fall through!	

._do_exit
	rts

; -------------------------------------------------------------------
; decrunch one byte
;
.get_decrunched_byte
{
	IF _COUNT_DECRUNCHES
	{
		INC decrunch_count
		BNE no_carry
		INC decrunch_count+1
		.no_carry
	}
	ENDIF

	ldy EXO_zp_len_lo
	bne _do_sequence
	ldx EXO_zp_len_hi
	bne _do_sequence2

	jsr _bit_get_bit1
	beq _get_sequence
; -------------------------------------------------------------------
; literal handling (13 bytes)
;
	jsr get_crunched_byte
	bcc _do_literal
; -------------------------------------------------------------------
; count zero bits + 1 to get length table index (10 bytes)
; y = x = 0 when entering
;
._get_sequence
._seq_next1
	iny
	jsr _bit_get_bit1
	beq _seq_next1
	cpy #$11
	bcs _do_exit
; -------------------------------------------------------------------
; calulate length of sequence (zp_len) (17 bytes)
;
	ldx tabl_bi - 1,y
	jsr _bit_get_bits
	adc tabl_lo - 1,y
	sta EXO_zp_len_lo
	lda EXO_zp_bits_hi
	adc tabl_hi - 1,y
	sta EXO_zp_len_hi
; -------------------------------------------------------------------
; here we decide what offset table to use (20 bytes)
; x is 0 here
;
	bne _seq_nots123
	ldy EXO_zp_len_lo
	cpy #$04
	bcc _seq_size123
._seq_nots123
	ldy #$03
._seq_size123
	ldx tabl_bit - 1,y
	jsr _bit_get_bits
	adc tabl_off - 1,y
	tay
; -------------------------------------------------------------------
; calulate absolute offset (zp_src) (27 bytes)
;
	ldx tabl_bi,y
	jsr _bit_get_bits;
	adc tabl_lo,y
	bcc _seq_skipcarry
	inc EXO_zp_bits_hi
	clc
._seq_skipcarry
	adc EXO_zp_dest_lo
	sta EXO_zp_src_lo
	lda EXO_zp_bits_hi
	adc tabl_hi,y
	adc EXO_zp_dest_hi
; -------------------------------------------------------------------
	cmp #HI(EXO_buffer_len)
	bcc _seq_offset_ok
	sbc #HI(EXO_buffer_len)
	clc
; -------------------------------------------------------------------
._seq_offset_ok
	sta EXO_zp_src_hi
	adc #HI(EXO_buffer_start)
	sta EXO_zp_src_bi
._do_sequence
	ldy #0
._do_sequence2
	ldx EXO_zp_len_lo
	bne _seq_len_dec_lo
	dec EXO_zp_len_hi
._seq_len_dec_lo
	dec EXO_zp_len_lo
; -------------------------------------------------------------------
	ldx EXO_zp_src_lo
	bne _seq_src_dec_lo
	ldx EXO_zp_src_hi
	bne _seq_src_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_src_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_src_bi
; -------------------------------------------------------------------
._seq_src_dec_hi
	dec EXO_zp_src_hi
	dec EXO_zp_src_bi
._seq_src_dec_lo
	dec EXO_zp_src_lo
; -------------------------------------------------------------------
	lda (EXO_zp_src_lo),y
; -------------------------------------------------------------------
._do_literal
	ldx EXO_zp_dest_lo
	bne _seq_dest_dec_lo
	ldx EXO_zp_dest_hi
	bne _seq_dest_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_dest_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_dest_bi
; -------------------------------------------------------------------
._seq_dest_dec_hi
	dec EXO_zp_dest_hi
	dec EXO_zp_dest_bi
._seq_dest_dec_lo
	dec EXO_zp_dest_lo
; -------------------------------------------------------------------
	sta (EXO_zp_dest_lo),y
	clc
	rts
}

; -------------------------------------------------------------------
; two small static tables (6 bytes)
;
.tabl_bit
{
	EQUB 2,4,4
}
.tabl_off
{
	EQUB 48,32,16
}

; -------------------------------------------------------------------
; get x + 1 bits (1 byte)
;
._bit_get_bit1
	inx
; -------------------------------------------------------------------
; get bits (31 bytes)
;
; args:
;   x = number of bits to get
; returns:
;   a = #bits_lo
;   x = #0
;   c = 0
;   EXO_zp_bits_lo = #bits_lo
;   EXO_zp_bits_hi = #bits_hi
; notes:
;   y is untouched
;   other status bits are set to (a == #0)
; -------------------------------------------------------------------
._bit_get_bits
{
	lda #$00
	sta EXO_zp_bits_lo
	sta EXO_zp_bits_hi
	cpx #$01
	bcc _bit_bits_done
	lda EXO_zp_bitbuf
._bit_bits_next
	lsr a
	bne _bit_ok
	jsr get_crunched_byte
	ror a
._bit_ok
	rol EXO_zp_bits_lo
	rol EXO_zp_bits_hi
	dex
	bne _bit_bits_next
	sta EXO_zp_bitbuf
	lda EXO_zp_bits_lo
._bit_bits_done
	rts
}
; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

\ ******************************************************************
\ *	Stored data
\ ******************************************************************

.VID_frame_start
EQUW	VID_default_frame_addr
.VID_frame_end
EQUW	VID_default_frame_addr + VID_default_frame_size

.osword_params
.osword_params_drive
EQUB 0				; drive
.osword_params_address
EQUD 0				; address
EQUB &03			; number params
EQUB &53			; command = read data multi-sector
.osword_params_track
EQUB 0				; logical track
.osword_params_sector
EQUB 0				; logical sector
.osword_params_size_sectors
EQUB &20 + DFS_sectors_to_load		; sector size / number sectors = 256 / 10
.osword_params_return
EQUB 0				; returned error value


\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

IF _ENABLE_CMD_LINE_PARAMS
.mode7_char_width_LO
FOR n,0,25,1
EQUB LO(n * MODE7_char_width)
NEXT

.mode7_char_width_HI
FOR n,0,25,1
EQUB HI(n * MODE7_char_width)
NEXT
ENDIF

\ ******************************************************************
\ *	MUSIC PLAYER
\ ******************************************************************

INCLUDE "6502\exomiser.asm"
INCLUDE "6502\vgmplayer.asm"

\ ******************************************************************
\ *	INTRO SEQUENCE
\ ******************************************************************

IF _SHOW_INTRO

; A is time in seconds
.wait_key
{
	tax
.wait_loop
	txa:pha
	\\ wait for keypress within time A
    ldx#100:ldy#0:lda#&81:jsr osbyte	
	pla:tax
	bcc done	; key pressed
	cpy #27
	beq done	; ESC pressed
	dex
	bne wait_loop
.done
	rts
}

; X/Y contain page to show
.scroll_page
{
	JSR MUS_init_decruncher
	
	\\ unpack to screen
	LDX #LO(TEMP_BUFFER)
	LDY #HI(TEMP_BUFFER)
	JSR MUS_unpack

	lda #LO(TEMP_BUFFER)
	sta debugptr+0
	lda #HI(TEMP_BUFFER)
	sta debugptr+1


	ldy #24
.main_loop
	tya:pha

	LDA #19:LDX #0:JSR osbyte 




IF TRUE
; hacking rapid inline code here for speed - to beat raster & keep 50Hz
	for i,0,23

		ldx #39
	.col_loop
		lda &7c00+40+i*40,x
		sta &7c00+i*40,x
		dex
		bpl col_loop

	next

ELSE

	; slower version
	lda #40
	sta readaddr+1
	lda #&7c
	sta readaddr+2 

	lda #0
	sta writeaddr+1
	lda #&7c
	sta writeaddr+2 	

	ldy #24
.row_loop
	tya:pha
	ldx #39
.col_loop
.readaddr
	lda &ffff,x
.writeaddr
	sta &ffff,x
	dex
	bpl col_loop

	lda readaddr+1
	clc
	adc #40
	sta readaddr+1
	lda readaddr+2
	adc #0
	sta readaddr+2

	lda writeaddr+1
	clc
	adc #40
	sta writeaddr+1
	lda writeaddr+2
	adc #0
	sta writeaddr+2


	pla:tay
	dey
	bpl row_loop
ENDIF


	ldy #39
.bot_loop
	lda (debugptr),y
	sta &7c00+24*40,y
	dey
	bpl bot_loop

	lda debugptr+0
	clc
	adc #40
	sta debugptr+0
	lda debugptr+1
	adc #0
	sta debugptr+1


	pla:tay
	dey
	;bpl main_loop
	bmi finished
	jmp main_loop
.finished

	rts
}



; X/Y contain page to show
.show_page
{
	TXA:PHA:TYA:PHA
	
	LDA #19:LDX #0:JSR osbyte
	LDA #6:STA &FE00:LDA #0:STA &FE01

	\\ Initialize compressed data stream
	\\ the title screen is an included binary at the VGM_stream_data memory address
	\\ (later overwritten by loaded VGMs)
	PLA:TAY:PLA:TAX
	JSR MUS_init_decruncher
	
	\\ unpack to screen
	LDX #&00
	LDY #&7C
	JSR MUS_unpack


	LDA #19:LDX #0:JSR osbyte
	LDA #6:STA &FE00:LDA #25:STA &FE01	
	
	rts
}

.introz
{
	.again
	LDX #LO(page_testcard)
	LDY #HI(page_testcard)
	JSR show_page
	LDA #2:JSR wait_key

	LDX #LO(page_bitshifters)
	LDY #HI(page_bitshifters)
	JSR show_page	
	LDA #2:JSR wait_key

	LDX #LO(page_title)
	LDY #HI(page_title)
	JSR scroll_page
	LDA #3:JSR wait_key

IF _HACK_CREDITS
	jsr creditz
ELSE
	LDX #LO(page_ip)
	LDY #HI(page_ip)
	JSR scroll_page	
	LDA #4:JSR wait_key
ENDIF

	LDX #LO(page_horsenburger)
	LDY #HI(page_horsenburger)
	JSR scroll_page	
	LDA #3:JSR wait_key

	LDX #LO(page_blockparty)
	LDY #HI(page_blockparty)
	JSR scroll_page
	LDA #4:JSR wait_key

	; black screen for a dramatic effect
	LDA #19:LDX #0:JSR osbyte
	LDA #6:STA &FE00:LDA #0:STA &FE01
	LDA #1:JSR wait_key

	LDX #LO(page_frame)
	LDY #HI(page_frame)
	JSR show_page

;	jmp again

	rts
}

.os_load_credits_music EQUS "LOAD credits", 13
.creditz
{


;--------- CREDITS -----------------

	jsr fx_creditscroll_init

	; black screen for a dramatic effect
	LDA #19:LDX #0:JSR osbyte
	LDA #6:STA &FE00:LDA #0:STA &FE01
	LDA #1:JSR wait_key


	LDX #LO(CREDITS_DATA_PAGE)
	LDY #HI(CREDITS_DATA_PAGE)
	JSR show_page

	; start music
	; must happen after we unpack the credits page
	; since the music player uses the same exo decompressor
	; as the page data unpacker

	; *load the credits music to the streaming buffer
	; workspace which isnt in use at the moment!
	; can only just fit it on the disk let alone in ram as well
	ldx #LO(os_load_credits_music)
	ldy #HI(os_load_credits_music)
	jsr &fff7	; oscli

	; kick off the music player
	LDX #LO(credits_music_start)
	LDY #HI(credits_music_start)
	JSR vgm_init_stream

	LDX #LO(poll_player)
	LDY #HI(poll_player)
	JSR start_eventv


.creditsloop
	lda #19:ldx #0:jsr osbyte
	jsr fx_creditscroll_update
	; loop until all credits are shown
	beq creditsloop

;--------------------------------------
	
	; cleanup of the music player
	jsr stop_eventv
	rts
}


ENDIF


MACRO RESET_MAPCHAR

	MAPCHAR 'A', 'Z', 'A' 
	MAPCHAR 'a', 'z', 'z'
	MAPCHAR '0', '9', '0'
	MAPCHAR '?', '?'
	MAPCHAR '!', '!'
	MAPCHAR '.', '.'
	MAPCHAR ' ', ' '

ENDMACRO

INCLUDE "6502/creditscroll.asm"

.code_end

\ ******************************************************************
\ *	MUSIC DATA
\ ******************************************************************

.music_data
IF _MUS_BUFFER_2K
	; 'Final' version of music compressed using:
	;  exomizer.exe raw -c -m 2048 <file.raw> -o <file.exo>
	INCBIN "data/bbcapple.bin.exo"
; This fix is now in place, so no need for SKIP and frees up a bit of RAM
	IF FALSE	
		; gotta pad this out to same size as music below so that track alignment is good
		; TODO: a better fix is to sort the disk image packing
		SKIP (music_data+12095)-*
	ENDIF
ELSE
	; 'Party' version of music compressed using:
	;  exomizer.exe raw -c -m 1024 <file.raw> -o <file.exo>
	INCBIN "data/bbcapple-doesthiscompressbetter.bin.exo"
ENDIF







\\ Exomiser unpack buffer (must be page aligned)
\\ SM: moved into EXE block, so we can utilize it for storing intro data prior to the video playing back.
\\ (when the data in here will get overwritten)
ALIGN &100
.EXO_buffer_start
; We have 3Kb to play with. Let's cram it in!


; this data block is copied to CREDITS_DATA_ADDR for later use in credits
; since by then this workspace will have been overwritten
; Stored first to take advantage of existing page alignment
ALIGN 256
.relocated_data

.teletext_font_data				; we use 16/25 lines of this screen
INCBIN "data/font_5x5_shifted_trimmed.mode7.bin"
.teletext_font_data_end

ALIGN 256
.page_credits
INCBIN "data/pages/credits.txt.bin.exo"
.page_credits_end

.relocated_data_end

; ----- page data ----------


.page_testcard
INCBIN "data/pages/testcard.txt.bin.exo"
.page_bitshifters
INCBIN "data/pages/bslogo.txt.bin.exo"
.page_title
INCBIN "data/pages/balogo.txt.bin.exo"
.page_blockparty
INCBIN "data/pages/blockparty.txt.bin.exo"
.page_ip
INCBIN "data/pages/inversephase.txt.bin.exo"
.page_horsenburger
INCBIN "data/pages/horsenburger.txt.bin.exo"
.page_frame
INCBIN "data/pages/frame.txt.bin.exo"


CREDITS_DATA_ADDR = &400
CREDITS_DATA_FONT = CREDITS_DATA_ADDR+0
CREDITS_DATA_PAGE = CREDITS_DATA_ADDR+768


; code routine to relocate credits data to CREDITS_DATA_ADDR
; also stored in workspace as this is only called once at startup
.relocate_credits
{
	ldx #0
.loop
	lda relocated_data+0,x
	sta CREDITS_DATA_ADDR+0,x
	lda relocated_data+256,x
	sta CREDITS_DATA_ADDR+256,x
	lda relocated_data+512,x
	sta CREDITS_DATA_ADDR+512,x
	lda relocated_data+768,x
	sta CREDITS_DATA_ADDR+768,x
	inx
	bne loop
	rts
}

mode7_font_data = CREDITS_DATA_FONT
mode7_font_data_second_row = mode7_font_data + 40

.device_test_start_clock
{
	LDA #0
	STA clock_param+0
	STA clock_param+1
	STA clock_param+2
	STA clock_param+3
	STA clock_param+4

	LDX #LO(clock_param)
	LDY #HI(clock_param)
	LDA #&2
	JSR osword

	RTS
}

.device_test_stop_clock
{
	LDX #LO(clock_param)
	LDY #HI(clock_param)
	LDA #&1
	JSR osword

	\\ Check speed of inital load
	LDA clock_param
	CMP #50										; anything < 1/2 second considered fast
	BCS slow_device

	\\ Fast device detected!
	\\ Change to load by sector

	LDA #1
	STA sectors_to_load_1+1
	STA sectors_to_load_2+1
	STA sectors_to_load_3+1
	ORA #&20
	STA osword_params_size_sectors

	.slow_device
	LDA #&2C				; BIT absolute
	STA main_start_clock
	STA main_stop_clock		; nuke calls to start & stop clock functions

	RTS	
}

WORKSPACE_FREE = EXO_buffer_len-(*-EXO_buffer_start)

SKIP WORKSPACE_FREE


.EXO_buffer_end



\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************
ALIGN 256	; pad to nearest page to ensure exe fills a complete sector
.end

; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************



IF _MUS_BUFFER_2K
\\ Exomiser music unpack buffer
.MUS_buffer_start
SKIP MUS_buffer_len
.MUS_buffer_end
ENDIF

\ ******************************************************************
\ *	EXO VGM data file
\ * This must be compressed using the following flags:
\ * exomizer.exe raw -c -m 1024 <file.raw> -o <file.exo>
\ ******************************************************************

ALIGN &100
.STREAM_buffer_start

; ok bit of a cheeky re-use of RAM here
; during assembly we reserve this memory buffer
; but it is not saved as part of the code segment
; so we incbin the credits music file here
; and save it to disk further below (same load address)
; so it can be loaded back into RAM when the credits sequence begins
.credits_music_start
INCBIN "data/bbcacred.bin.exo"
; round up to a page in length (makes track alignment math easier)
ALIGN 256
.credits_music_end

; ensure we reserve further bytes to make buffer STREAM_buffer_size
SKIP STREAM_buffer_size-(*-STREAM_buffer_start)
.STREAM_buffer_end

TEMP_BUFFER = STREAM_buffer_start


PRINT "Code size =", code_end-start, " (", ~(code_end-start), ") bytes."
PRINT "Music size =", end-music_data, " (", ~(end-music_data), ") bytes."
PRINT "Video decompress buffer size =", EXO_buffer_end-EXO_buffer_start, " (", ~(EXO_buffer_end-EXO_buffer_start), ") bytes."
PRINT "Streaming buffer size =", STREAM_buffer_end-STREAM_buffer_start, " (", ~(STREAM_buffer_end-STREAM_buffer_start), ") bytes."

PRINT "TOP =", ~*
PRINT "GUARD = &7C00"
PRINT "RAM Bytes free =", &7C00-P%
PRINT " Free Workspace:", WORKSPACE_FREE, " bytes"

\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "!boot", start, end
EXE_SIZE = end-start
CREDITS_MUSIC_SIZE = credits_music_end-credits_music_start

PADDING_SIZE = ((DISK1_first_track*DFS_track_size)-512)-EXE_SIZE-CREDITS_MUSIC_SIZE

PRINT "EXE Size is ", ~EXE_SIZE, "bytes"

; write the credits music to the disk. Just enough space!
PRINT "Credits music Size is ", ~CREDITS_MUSIC_SIZE, "bytes"
SAVE "credits", credits_music_start, credits_music_end, credits_music_start, credits_music_start

; write a padding file to disk to ensure we get the video on the right track number
PRINT "Padding to track", DISK1_first_track, "is ", ~PADDING_SIZE, "bytes"
SAVE "b.tshftrs", start, start+PADDING_SIZE, 0, 0

